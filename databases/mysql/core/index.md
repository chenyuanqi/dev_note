
### 索引
索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。  
索引是依靠某些数据结构和算法来组织数据，最终引导用户快速检索出所需要的数据。  
索引有 2 个特点：  
1、通过数据结构和算法来对原始的数据进行一些有效的组织  
2、通过这些有效的组织，可以引导使用者对原始数据进行快速检索  
mysql 为了快速检索数据，也用到了一些好的数据结构和算法，来组织表中的数据，加快检索效率。  

实现索引的方式有很多种。这里主要说说三种常见的索引模型，分别是哈希表、有序数组和搜索树。  
哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key， 就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数 把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。哈希表这种结构适用于只有等值查询的场景。  

![mysql-index-hash](../images/mysql-index-01.png)  

图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链 表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询 的速度是很慢的。  

有序数组在等值查询和范围查询场景中的性能就都非常优秀。假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就 麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，有序数组索引只适用于静态存储引擎。  

![mysql-index-sorted-array](../images/mysql-index-02.png)  

二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照下图中的搜索顺序就是按照 UserA -> UserC -> UserF -> User2 这个路径得到。这个时间复杂度是 O(log(N))。为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个 保证，更新的时间复杂度也是 O(log(N))。    
树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从 左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉 树。其原因是，索引不止存在内存中，还要写到磁盘上。  
为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就 不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中。

![mysql-index-tree](../images/mysql-index-tree.png)  

不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方 案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中。  

### 索引原理
索引的本质：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。  

**磁盘中数据的存取**  
以机械硬盘来说，先了解几个概念。  
扇区：磁盘存储的最小单位，扇区一般大小为 512Byte。  
磁盘块：文件系统与磁盘交互的的最小单位（计算机系统读写磁盘的最小单位），一个磁盘块由连续几个（2^n）扇区组成，块一般大小一般为 4KB。  
磁盘读取数据：磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，表示每分钟能转 7200 次，也就是说 1 秒钟能转 120 次，旋转延迟就是 1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 5+4.17 = 9ms 左右，听起来还挺不错的，但要知道一台 500 -MIPS 的机器每秒可以执行 5 亿条指令，因为指令依靠的是电的性质，换句话说执行一次 IO 的时间可以执行 40 万条指令，数据库动辄十万百万乃至千万级数据，每次 9 毫秒的时间，显然是个灾难。  

**mysql 中的页**  
mysql 中和磁盘交互的最小单位称为页，页是 mysql 内部定义的一种数据结构，默认为 16kb，相当于 4 个磁盘块，也就是说 mysql 每次从磁盘中读取一次数据是 16KB，要么不读取，要读取就是 16KB，此值可以修改的。

**数据检索过程**  
我们对数据存储方式不做任何优化，直接将数据库中表的记录存储在磁盘中，假如某个表只有一个字段，为 int 类型，int 占用 4 个 byte，每个磁盘块可以存储 1000 条记录，100 万的记录需要 1000 个磁盘块，如果我们需要从这 100 万记录中检索所需要的记录，需要读取 1000 个磁盘块的数据（需要 1000 次 io），每次 io 需要 9ms，那么 1000 次需要 9000ms=9s，100 条数据随便一个查询就是 9 秒，这种情况我们是无法接受的，显然是不行的。  

**我们迫切的需求是什么？**  
我们迫切需要这样的数据结构和算法：  
需要一种数据存储结构：当从磁盘中检索数据的时候能，够减少磁盘的 io 次数，最好能够降低到一个稳定的常量值  
需要一种检索算法：当从磁盘中读取磁盘块的数据之后，这些块中可能包含多条记录，这些记录被加  

**循环遍历查找**  
从一组无序的数据中查找目标数据，常见的方法是遍历查询，n 条数据，时间复杂度为 O (n)，最快需要 1 次，最坏的情况需要 n 次，查询效率不稳定。  

**二分法查找**  
二分法查找也称为折半查找，用于在一个有序数组中快速定义某一个需要查找的数据。  
原理是：  
先将一组无序的数据排序（升序或者降序）之后放在数组中，此处用升序来举例说明：用数组中间位置的数据 A 和需要查找的数据 F 对比，如果 A=F，则结束查找；如果 A<F，则将查找的范围缩小至数组中 A 数据右边的部分；如果 A>F，则将查找范围缩小至数组中 A 数据左边的部分，继续按照上面的方法直到找到 F 为止。  
```
[1,2,3,4,5,6,7,8,9]
第 1 次查找：[1,2,3,4,5,6,7,8,9] 中间位置值为 5，9>5，将查找范围缩小至 5 右边的部分：[6、7、8、9]
第 2 次查找：[6、7、8、9] 中间值为 8，9>8 ，将范围缩小至 8 右边部分：[9]
第 3 次查找：在 [9] 中查找 9，找到了
```
二分法查找时间复杂度是:O (logN)(N 为数据量)，100 万数据查找最多只需要 20 次（2^20=1048576‬）  
二分法查找数据的优点：定位数据非常快，前提是：目标数组是有序的。  

**有序数组**  
如果我们将 mysql 中表的数据以有序数组的方式存储在磁盘中，那么我们定位数据步骤是：  
1、取出目标表的所有数据，存放在一个有序数组中  
2、如果目标表的数据量非常大，从磁盘中加载到内存中需要的内存也非常大  
步骤取出所有数据耗费的 io 次数太多，步骤 2 耗费的内存空间太大，还有新增数据的时候，为了保证数组有序，插入数据会涉及到数组内部数据的移动，也是比较耗时的，显然用这种方式存储数据是不可取的。  

**链表**  
链表相当于在每个节点上增加一些指针，可以和前面或者后面的节点连接起来，就像一列火车一样，每节车厢相当于一个节点，车厢内部可以存储数据，每个车厢和下一节车厢相连。  
链表分为单链表和双向链表。  
单链表是每个节点中有持有指向下一个节点的指针，只能按照一个方向遍历链表；双向链表是每个节点中两个指针，分别指向当前节点的上一个节点和下一个节点。  

链表的优点：  
可以快速定位到上一个或者下一个节点  
可以快速删除数据，只需改变指针的指向即可，这点比数组好  

链表的缺点：  
无法向数组那样，通过下标随机访问数据  
查找数据需从第一个节点开始遍历，不利于数据的查找，查找时间和无需数据类似，需要全遍历，最差时间是 O(N)  

**二叉查找树**  
二叉树是每个结点最多有两个子树的树结构，通常子树被称作 “左子树”（left subtree）和 “右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。二叉树有如下特性：  
1、每个结点都包含一个元素以及 n 个子树，这里 0≤n≤2。  
2、左子树和右子树是有顺序的，次序不能任意颠倒，左子树的值要小于父结点，右子树的值要大于父结点。  

二叉树的优缺点：  
查询数据的效率不稳定，若树左右比较平衡的时，最差情况为 O(logN)，如果插入数据是有序的，退化为了链表，查询时间变成了 O(N)  
数据量大的情况下，会导致树的高度变高，如果每个节点对应磁盘的一个块来存储一条数据，需 io 次数大幅增加，显然用此结构来存储数据是不可取的

**平衡二叉树（AVL 树）**  
平衡二叉树是一种特殊的二叉树，所以他也满足前面说到的二叉查找树的两个特性，同时还有一个特性：  
它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。  

平衡二叉树相对于二叉树来说，树的左右比较平衡，不会出现二叉树那样退化成链表的情况，不管怎么插入数据，最终通过一些调整，都能够保证树左右高度相差不大于 1。这样可以让查询速度比较稳定，查询中遍历节点控制在 O(logN) 范围内。如果数据都存储在内存中，采用 AVL 树来存储，还是可以的，查询效率非常高。不过我们的数据是存在磁盘中，用过采用这种结构，每个节点对应一个磁盘块，数据量大的时候，也会和二叉树一样，会导致树的高度变高，增加了 io 次数，显然用这种结构存储数据也是不可取的。  

**B - 树**  
B杠树，千万不要读作 B 减树了，B - 树在是平衡二叉树上进化来的，前面介绍的几种树，每个节点上面只有一个元素，而 B - 树节点中可以放多个元素，主要是为了降低树的高度。一棵 m 阶的 B-Tree 有如下特性：  
1、每个节点最多有 m 个孩子，m 称为 b 树的阶  
2、除了根节点和叶子节点外，其它每个节点至少有 Ceil (m/2) 个孩子  
3、若根节点不是叶子节点，则至少有 2 个孩子  
4、所有叶子节点都在同一层，且不包含其它关键字信息  
5、每个非终端节点包含 n 个关键字（健值）信息  
6、关键字的个数 n 满足：ceil (m/2)-1 <= n <= m-1  
7、ki (i=1,…n) 为关键字，且关键字升序排序  
8、Pi (i=1,…n) 为指向子树根节点的指针。P (i-1) 指向的子树的所有节点关键字均小于 ki，但都大于 k (i-1)

使用 B - 树定位某个值还是很快的 (10 亿数据中 3 次 io 操作 + 内存中二分法)，但是也是有缺点的：B - 不利于范围查找，比如上图中我们需要查找 [15,36] 区间的数据，需要访问 7 个磁盘块（1/2/7/3/8/4/9），io 次数又上去了，范围查找也是我们经常用到的，所以 b - 树也不太适合在磁盘中存储需要检索的数据。  

**b + 树**  
b + 树的特征：  
1、每个结点至多有 m 个子女  
2、除根结点外，每个结点至少有 [m/2] 个子女，根结点至少有两个子女  
3、有 k 个子女的结点必有 k 个关键字  
4、父节点中持有访问子节点的指针  
5、父节点的关键字在子节点中都存在（如上面的 1/20/35 在每层都存在），要么是最小值，要么是最大值，如果节点中关键字是升序的方式，父节点的关键字是子节点的最小值  
6、最底层的节点是叶子节点  
7、除叶子节点之外，其他节点不保存数据，只保存关键字和指针  
8、叶子节点包含了所有数据的关键字以及 data，叶子节点之间用链表连接起来，可以非常方便的支持范围查找

b + 树与 b - 树的不同在于：  
1、b + 树中一个节点如果有 k 个关键字，最多可以包含 k 个子节点（k 个关键字对应 k 个指针）；而 b - 树对应 k+1 个子节点（多了一个指向子节点的指针）  
2、b + 树除叶子节点之外其他节点值存储关键字和指向子节点的指针，而 b - 树还存储了数据，这样同样大小情况下，b + 树可以存储更多的关键字  
3、b + 树叶子节点中存储了所有关键字及 data，并且多个节点用链表连接，从上图中看子节点中数据从左向右是有序的，这样快速可以支撑范围查找（先定位范围的最大值和最小值，然后子节点中依靠链表遍历范围数据）

### 索引模型 
mysql 内部索引是由不同的引擎实现的，InnoDB 和 MyISAM 这两种引擎中的索引都是使用 b + 树的结构来存储的。  

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组 织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的，每一个索引在 InnoDB 里面对应一棵 B+ 树。  

根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引 （clustered index）。  
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引 （secondary index）。  

基于主键索引和普通索引的查询：  
如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；  
如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引 树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。  
也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量 使用主键查询。   

**索引维护**  
B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。
插入新行需要在最新记录后插入新的记录，但是如果在数据中间插入数据，则需要逻辑上挪动后面的数据。更糟糕的是如果节点所在数据页满了的情况还需要申请一个新的数据页，然后挪动部分数据过去，这个过程叫页分裂。  

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。  
当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合 并。合并的过程，可以认为是分裂过程的逆过程。  

基于上面的索引维护过程，自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。由于每个非主键索引的叶子节点上都是主键的值，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。  
而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。用业务字段直接做主键的场景通常是 KV 场景，由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。  

优先考虑“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

### 索引管理
索引分为聚集索引和非聚集索引。  
每个表有且一定会有一个聚集索引，整个表的数据存储在聚集索引中，mysql 索引是采用 B + 树结构保存在文件中，叶子节点存储主键的值以及对应记录的数据，非叶子节点不存储记录的数据，只存储主键的值。当表中未指定主键时，mysql 内部会自动给每条记录添加一个隐藏的 rowid 字段（默认 4 个字节）作为主键，用 rowid 构建聚集索引。聚集索引在 mysql 中又叫`主键索引`。  
非聚集索引（辅助索引）也是 b + 树结构，不过有一点和聚集索引不同，非聚集索引叶子节点存储字段（索引字段）的值以及对应记录主键的值，其他节点只存储字段的值（索引字段）。每个表可以有多个非聚集索引。mysql 中非聚集索引分为`单列索引、多列索引（又称复合索引）、唯一索引`。  
> 单列索引即一个索引只包含一个列。  
> 多列索引即一个索引包含多个列。  
> 唯一索引即索引列的值必须唯一，允许有一个空值。  

**覆盖索引**  
覆盖索引指的是可以直接提供查询结果，不需要回表。  
于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。  

我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？  
如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。  
当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

**数据检索的过程**  
如果需要查询 id=14 的数据，只需要在左边的主键索引中检索就可以了。
如果需要搜索 name='Ellison' 的数据，需要 2 步：  
1、先在辅助索引中检索到 name='Ellison' 的数据，获取 id 为 14  
2、再到主键索引中检索 id 为 14 的记录  
辅助索引相对于主键索引多了第二步。  

**创建索引**  
有两种方式
```sql
# 方式 1
create [unique] index 索引名称 on 表名(列名[(length)]);
# 方式 2
alter 表名 add [unique] index 索引名称 on (列名[(length)]);
```

**删除索引**  
```sql
drop index 索引名称 on 表名;
```

**查看索引**  
查看某个表中所有的索引信息如下：  
```sql
show index from 表名;
```

**索引修改**  
可以先删除索引，再重建索引。  
```sql
drop index 索引名称 on 表名;
create [unique] index 索引名称 on 表名(列名[(length)]);
```

**最左前缀原则**  
索引项是按照索引定义里面出现的字段顺序排序的。B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。  

不只是索引的全部定义，只要满足左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的左 N 个字段，也可以是字符串索引的左 M 个字符。  

在建立联合索引的时候，如何安排索引内的字段顺序呢？  
第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。  
接着，我们要考虑的原则就是索引字段所占用的空间。  

**索引下推**  
MySQL 5.6 引入的索引下推优化 ICP（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。  
ICP 是一种在存储引擎层使用索引过滤数据的一种优化方式，ICP 可以减少存储引擎访问基表的次数以及 MySQL 服务器访问存储引擎的次数。  

比如我们需要查询 name 以 vikey 开头的，性别为 1 的记录数，sql 如下：  
```sql
select count(id) from test1 a where name like 'vikey%' and sex = 1;
```
这个查询语句的过程：
1、走 name 索引检索出以 vikey 的第一条记录，得到记录的 id  
2、利用 id 去主键索引中查询出这条记录 R1  
3、判断 R1 中的 sex 是否为 1，然后重复上面的操作，直到找到所有记录为止。  
上面的过程中需要走 name 索引以及需要回表操作。  
如果采用 ICP 的方式，我们可以这么做，创建一个 (name,sex) 的组合索引，查询过程就会变成这样：  
1、走 (name,sex) 索引检索出以 vikey 的第一条记录，可以得到 (name,sex,id)，记做 R1  
2、判断 R1.sex 是否为 1，然后重复上面的操作，知道找到所有记录为止  
这个过程中不需要回表操作了，通过索引的数据就可以完成整个条件的过滤，速度比上面的更快一些。  

**索引使用的一些建议**  
1、在区分度高的字段上面建立索引可以有效的使用索引，区分度太低，无法有效的利用索引，可能需要扫描所有数据页，此时和不使用索引差不多  
2、联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，mysql 会一直向右匹配直到遇到范围查询 (>、<、between、like) 就停止匹配，比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立 (a,b,c,d) 顺序的索引，d 是用不到索引的，如果建立 (a,b,d,c) 的索引则都可以用到，a,b,d 的顺序可以任意调整  
3、查询记录的时候，少使用 \*，尽量去利用索引覆盖，可以减少回表操作，提升效率  
4、有些查询可以采用联合索引，进而使用到索引下推（IPC），也可以减少回表操作，提升效率  
5、禁止对索引字段使用函数、运算符操作，会使索引失效  
6、字符串字段和数字比较的时候会使索引无效  
7、模糊查询 '% 值 %' 会使索引无效，变为全表扫描，但是 ' 值 %' 这种可以有效利用索引  
8、排序中尽量使用到索引字段，这样可以减少排序，提升查询效率  

### 常见问题
1、怎么删除表的前 10000 行  
第一种方式，直接执行 delete from T limit 10000，单个语句占用时间长，锁 的时间也比较长；而且大事务还会导致主从延迟。  
第二种方式，在 20 个连接中同时执行 delete from T limit 500，会人为造成锁冲突。  
第三种方式，在一个连接中循环执行 20 次 delete from T limit 500，这样相对较好。

2、选择唯一索引还是普通索引  
这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响，建议尽量选择普通索引。  

执行查询的语句是 select id from T where k=5，在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点。
> 对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录， 直到碰到第一个不满足 k=5 条件的记录。  
> 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停 止继续检索。  

InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。  
当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer（实际上它是可以持久化的数据）中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。  
对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了，所以唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。  
> 插入新记录时，这个记录要更新的目标页在内存中。对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；而对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。  
> 插入新记录时，这个记录要更新的目标页不在内存中。对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。  

change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。  
对于写多读少的场景，change buffer 使用效果最好，相反 change buffer 的维护代价会增加。

3、为什么有时候索引会选错以及相应的解决方案是什么？  
选择索引是优化器的工作，优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。  
在数据库里面，扫描行数是影响执行代价的因素之一 ———— 扫描的行数越少，意味着访问磁盘数 据的次数越少，消耗的 CPU 资源越少。  
> 扫描行数如何判断？  
> 需要根据统计信息（即索引的“区分度”，一个索引上不同的值越多，这个索引的区分度就越好）来估算记录数。  
> 一个索引上不同的值的个数，我们称之为“基数”（cardinality）。基数的计算是通过采样统 计的方法。采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。   

扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。优化器会估算每个选择的代价，比如存在主键的方案会认为扫描主键索引更快但实际上并不是最优解。  
索引选择错误的情况比如：  
> 1、条件中有 or，即使其中有条件带索引也不会使用  
> 2、对于多列索引，不是使用的第一部分 (第一个)  
> 3、like 查询是以 % 开头  
> 4、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引  
> 5、如果 mysql 估计使用全表扫描要比使用索引快  

索引选择错误的解决方案主要有如下几种：  
> 1、相对粗暴的方法，采用 force index 强行选择一个索引，相对应的扩展性和敏捷度比较低  
> 2、如果 explain 的结果说明是索引统计信息不准确导致的，可以使用 analyze table 解决  
> 3、修改语句，引导 MySQL 使用我们期望的索引，比如增加排序分组逻辑  
> 4、在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择或删掉误用的索引  

4、怎么给字符串字段加索引？  
有如下四种方式可以考虑：  
> 1、直接创建完整索引，这样可能比较占用空间；  
> 2、创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引（因为系统并不确定前缀索引的定义是否截断了完整信息）；  
> 使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。那如何定义好长度呢？比如根据如下 sql 语句计算损失的区分度（举个例子，设定可接受的损失比例 3%，在返回的 L5 ~ L7 中找出不小于 L* 97% 的值就可以确认前缀索引的长度）  
> select count(distinct email) as L from user;  
> select count(distinct left(email, 5)) as L5, count(distinct left(email, 6)) as L6, count(distinct left(email, 7)) as L7 from user;  
> 3、倒序存储及查询（使用 reverse 函数），再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；  
> 4、创建 hash 字段索引（使用 crc32 函数），查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样， 都不支持范围扫描

5、Sql 语句逻辑相同，为什么性能差异巨大？  
对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。  
> 1、条件字段函数操作  
> 比如条件使用 month() 函数，就会导致全索引扫描。为了能够用上索引的快速定位能力，需要把 SQL 语句改成基于字段本身的范围查询（比如 between "xxxx-xx-xx" and "xxxx-xx-xx"），但是需要注意补全年份。  
> 即使是对于不改变有序性的函数，也不会考虑使用索引。比如条件语句是 id+1=10000，MySQL 优化器还是不能用 id 索引快速定位 到 9999 这一行，需要手动改写成 where id = 10000 -1 才可以。  
> 2、隐式类型转换  
> 比如字段 field 的类型是 varchar(32)，条件语句是 field=1111，实际执行的语句是 CAST(filed AS signed int)=1111，优化器就会放弃走树搜索逻辑。  
> 3、隐式字符编码转换  
> 比如两个关联表的字符集一个是 utf8，一个是 utf8mb4，它们的关联查询也回导致全表扫描。实际上，字符集不同，utf8mb4 是 utf8 的超集，就会发生这样的转换 CONVERT(field USING utf8mb4)="xxx"。这个时候，要么修改表的字符集保持一致，要么保证条件语句的字段值进行相关字符集转换操作。  
> 

6、导致慢查询性能的问题？  
a、索引没设计好  
一般通过紧急创建索引来解决，MySQL 5.6 版本以后，创建索引都支持 Online DDL 了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行 alter table 语句。  
主从数据库中，比较理想的是能够在备库先执行，如不紧急就考虑类似 gh-ost 这样的方案更加稳妥  
> 1、在备库B上执行 set sql_log_bin=off，也就是不写 binlog，然后执行 alter table 语句加上索引；  
> 2、执行主备切换；  
> 3、这时候，主库是 B，备库是 A。在 A 上执行 set sql_log_bin=off，然后执行 alter table 语句加上索引。

b、语句没写好  
MySQL 5.7 提供了query_rewrite 功能，可以把输入的一种语句改写成另外一种模式。  
call query_rewrite.flush_rewrite_rules() 这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。  
> 比如，增加一个语句改写规则：  
> insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");

c、mysql 选错了索引  
参考问题 3。  





