
### 排序
通常，我们需要根据指定的字段排序来显示结果。   
MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。按字段排序可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。  
> sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。  
> 如果要排序 的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。  

一般地，排序采用全字段排序，它的执行流程：  
1、初始化 sort_buffer，确定放入 select 的字段；  
2、（从索引）找到满足条件的主键 id；  
3、到主键 id 索引取出整行，取 select 的字段值存入 sort_buffer；  
4、（从索引）找到满足条件的下一个主键 id；  
5、重复步骤 3 和 4，直到条件不满足为止；  
6、对 sort_buffer 中的数据按照指定字段做快速排序；  
7、按照排序结果取需要的行数返回客户端。  

全字段排序，如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。  
所以，如果排序的单行长度很大，需要采用另一种排序算法：rowid 排序。  
> max_length_for_sort_data 是 MySQL 中专门控制用于排序的行数据的长度的一个参数。  
> 如果单行的长度超过这个值，MySQL 就认为单行太大，要换 rowid 排序算法。  
> 
> rowid 实际是每个引擎用来唯一标识数据行的信息。  
> 如果你创建的表没有主键，或者把一个表的主键删掉了，那么 InnoDB 会自 己生成一个长度为 6 字节的 rowid 来作为主键。  

rowid 排序放入 sort_buffer 的字段，只有要排序的列和主键 id，所以它的流程是这样的：  
1、初始化 sort_buffer，确定放入要排序的列和主键 id；  
2、（从索引）找到满足条件的主键 id；  
3、到主键 id 索引取出整行，取要排序的列和主键 id 的字段值存入 sort_buffer；  
4、（从索引）找到满足条件的下一个主键 id；  
5、重复步骤 3 和 4，直到条件不满足为止；  
6、对 sort_buffer 中的数据按照指定字段进行排序；  
7、遍历排序结果，取需要的行数，并按照主键 id 的值到原表取出 select 的字段返回给客户端。  

如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这 样排序过程中一次可以排序更多行，但是需要再回到原表去取数据；  
如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。  
体现了 MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。所以，MySQL 做排序是一个成本比较高的操作。  
但是，并不是所有 order by 都需要排序操作的。MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无序的。而且，排序在有覆盖索引（索引有维护代价，需要权衡）的前提下也会简化执行流程。  

### 随机排序方法  
随机排序，最容易联想到的是 order by rand()。  

order by rand() 使用了内存临时表，内存临时表排序的时 候使用了 rowid 排序方法。order by rand() 的执行流程：  
1、创建一个临时表（没有创建索引）。  
这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段 是 double 类型（记为字段 R），第二个字段是 varchar(64) 类型（记为字段 W）。  
2、 从数据表中，按主键顺序取出所有的 select 字段值。对于每一个字段值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和它分别存入临时表的 R 和 W 字段中。   
3、 接下来，在这个没有索引的内存临时表上按照字段 R 进行排序。  
4、 初始化 sort_buffer。  
sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。  
5、 从内存临时表中一行一行地取出 R 值和位置信息，分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描。  
6、 在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会 增加扫描行数。  
7、 排序完成后，取出需要行数的位置信息，依次到内存临时表中取出字段值，返回给客户端。

并不是所有的临时表都是内存表，tmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。  
磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine 控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。  

不论是使用哪种类型的临时表，order by rand() 这种写法都会让计算过程非常复杂，需要大量的扫描行数，因此排序过程的资源消耗也会很大。  

更好的排序方法思路：  
1、取得这个表的主键 id 的最大值 M 和最小值 N（取 max(id) 和 min(id) 都是不需要扫描索引的）;  
2、用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() + N;  
3、取不小于 X 的第一个 ID 的行（可以用索引快速定位）。
```mysql
select max(id),min(id) into @M,@N from t;
set @X=floor((@M-@N+1)*rand() + @N);
select * from t where id>=@X limit 1;
```
但是，由于 ID 中间可能存在空洞，选择不同行的概率不一样，所以不是真正的随机。那么，为了得到更加严格随机的结果，排序方法的思路改成这样：  
1、取得整个表的行数，并记为 C；  
2、取得 Y = floor(C * rand())，floor 是为了取整数部分；  
3、再用 limit Y,1 取得一行。  
```mysql
select count(*) into @C from t; 
set @Y = floor(@C * rand()); 
#  limit 后面的参数不能直接跟变量
set @sql = concat("select * from t limit ", @Y, ",1"); 
prepare stmt from @sql; 
execute stmt; 
DEALLOCATE prepare stmt;
```
显然，扫描的行数是 C+Y+1，比上面的排序思路付出的代价更高，但是比 order by rand() 好很多。  
但是，如果表记录很大，随机到很大的 Y 值时，效率还是相对较低的。  

