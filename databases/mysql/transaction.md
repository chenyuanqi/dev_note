### 一  事务概念
当一个业务逻辑需要多个 sql 完成时，如果其中某条 sql 语句出错，则希望整个操作都退回，使用事务可以完成退回的功能，保证业务逻辑的正确性。比如银行的转账，任意一个步骤出错，就应该全部停止回滚。  

事务四大特性(简称 ACID)：
- 原子性(Atomicity)：		事务的全部操要么全部完成，要么都不执行；
- 一致性(Consistency)：	    并行执行的多个事务，执行结果必须与串行执行结果一致；
- 隔离性(Isolation)：		事务的执行不受其他事务的干扰，但中间结果对其他事务透明的；
- 持久性(Durability)：		已提交事务，系统必须保证该事务对数据库的改变不被丢失。

注意：
- 表必须是 innodb 或 bdb 类型，才可以对此表使用事务 
- innodb 事务原理：对当前操作的行加锁；适合插入增删改（写入速度快），其他引擎常见的是对整张表加锁，查询速度很快。

事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。 InnoDB 是高版本 MySQL 的默认的存储引擎，因此就以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。

**MVCC**  
MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。  
InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。  
REPEATABLE READ（可重读）隔离级别下 MVCC 工作流：  

- SELECT：InnoDB 会根据以下条件检查每一行记录：第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的。第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。
- INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。
- DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。
- UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识保存这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。

### 二 事务使用
#### 2.1 自动提交
在 mysql 中事务默认自动提交，通过语句查看是否自动提交：
```sql
show variables like '%commit%';
set autocommit=off;	                    # 该语句可以关闭自动提交，但是要注意，关闭后所有的事务都需要手动提交
```
如果需要明确通过 commit，rollback 来提交事务和回滚事务，那么需要使用事务控制命令来开始事务。事务常用命令：`begin  commit  rollback`

事务示例：
```
终端 1：                                     终端 2：
----------------------------------------------------------------------------------------------

步骤 1：打开两个终端，连接 mysql，使用同一个数据库，操作同一张表
select * from users;                        begin;      # 或者 start transaction
                                            insert into users(name) values('张飞');
----------------------------------------------------------------------------------------------

步骤 2：终端 1 查询结果（查不到）
select * from users;
----------------------------------------------------------------------------------------------

步骤 3:终端 2 提交
                                            commit;
----------------------------------------------------------------------------------------------

步骤 4：终端 1 再次查询
select * from users;
---------------------------------------------------------------------------
```

#### 2.1 commit 与 commit and chain
- commit：提交后，别的线程可以查看到提交的结果
- commit and chain：提交后再开启一个新的事务，别的线程无法查看到刚才提交的结果

#### 2.2 save point
在事务中可以通过定义 savepoint，指定回滚事务的一个部分，但是不能指定提交事务的一个部分，

使用方式：
```sql
# 在事务中：
save point test;            # 设置一个回滚点 test
rollback to savepoint test; 
```

### 三 隔离级别
#### 3.0 事务的安全隐患
事务会产生三种问题（尤其是并发场合）：
- 脏读：一个事务读取到了另外一个事务未提交数据
- 虚读：即不可重复读，在同一个事务中，两次读取到的数据不一样
- 幻读：一个事务操作数据表中所有记录，另一个事务添加了一个数据，则前者查询不到自己的修改

为了解决上述问题，SQL 标准定义了 4 种隔离级别，指定了事务中哪些数据改变其他事务可见，哪些数据改变其他事务不可见。  

低级别的隔离级别可以支持更高的并处理，同时占用的系统资源更少。

```sql
# 查看隔离级别：	
select @@tx_isolation

# 设置隔离级别：	
set session transaction isolation level 

# 隔离级别名:session 也可以改为 global，即全局的隔离级别
```

4个隔离级别：		
- read uncommitted：读未提交，会产生脏读、不可重复读、幻读
- read committter：读已提交，会产生不可重复度、幻读。Oracle 默认隔离级别。
- reapeatable read：可重复读，会产生幻读。MySQL 默认隔离级别
- serializebale：串行化，可所有问题

#### 3.1 读未提交--脏读
某个事务已经更新了一个数据，但是另一个事务在此时读取了一份数据，前一个事务回滚，后一个事务就会读取到不存在的数据。  
该事物隔离级别低，且响应提升性能空间少，所以用的较少。   


#### 3.2 读已提交--不可重复读
提交读是大多数数据库默认的隔离级别，但是不是 mysql 的默认级别。该级别是人们比较常能理解的：一个事务在开始到提交前所做的任何改变都是不可见的，只能等待提交后才能看到。  
在 MySQL 中，开启 A 事务和 B 事务，B 事务提交后，A 事务能够读取到更新的数据。  

虽然这个隔离级别屏蔽了脏读，但是这样会造成不可重复读：一个事务读取到了另外一个事务提交的数据，造成前后两次查询结果不一致。  

#### 3.3 可重复读--幻读
MySQL 默认隔离级别：确保同一事务的不同实例在并发读取数据时，会看到相同的数据行。  
但是会出现幻读：一个事务读到了另一个事务 insert 的数据，造成前后查询结果不一致。  

第 1 个事务实例对表中的所有数据进行了修改；   
第 2 个事务实例向表中插入一行；  
以后会发生操作第1个事务的用户发现表中存在没有被修改的行。  

#### 3.4 可串行化
在每个读的数据上加共享锁，强制事务排序，避免幻读，但是会导致大量的超时、锁竞争现象，一般不推荐使用。

#### 3.5 演示脏读
演示脏读（也包含不可重复度，因为窗口B在同一事务中查询到了不同的结果）：
```
# 假设 uid1 和 uid2 的账户都是 1000 元
# 窗口 A # 窗口 B
set global transaction read uncommitted; select * from account; # 得到二者都是 1000 元
start transaction; start transaction;
-- 转账操作 -- 
update accoutn set balance=balance-500 where uid=1;
update accoutn set balance=balance+500 where uid=2; 
select * from account; # uid1 为 500，uid2 为 1500，读取了未提交的数据
roolback;
# 两边此时拿到的数据已经不一样了
```

提升一档事务的隔离级别，重复上述操作，窗口B查询到的结果永远都是 1000，不会读取到窗口 A 的事务，避免了脏读。但是当窗口 A 提交后，窗口 B 的事务还是读取到了另外一个事务的数据，即不可重复度的现象还在。此时可以继续提升事务的隔离级别。 

### 四  分布式事务
#### 4.1 分布式事务简介
当前只有 InnoDB 支持分布式事务，一个分布式事务涉及多个行动，每个行动都是事务性的，所有行动必须一起成功完成，或者一起被回滚。  

MySQL 的分布式事务涉及一到多个资源管理器和一个事务管理器：
- RM 资源管理器：提供通向事务资源的途径。数据库服务器是一种资源管理器，可以提交、回滚由 RM 管理的事务，如：多台 MySQL 作为资源管理器
- TM 事务管理器：TM 与管理每个事务的 RNs 通信，用于协调作每个行动。在一个分布式事务中，哥哥单事务均是分布式事务的分支事务，分布式事务和各分支铜鼓一种命名方法标识

要执行一个分布式事务，必须知道这个分布式事务涉及了哪些资源管理器，并且把每个资源管理器的事务执行到事务可以被提交或回滚时。根据每个资源管理器报告的有关执行情况的内容，这些分支事务必须作为一个原子性操作全部提交或回滚。  

要管理一个分布式事务，必须考虑任何组件或连接网络可能会出现故障。  

用于执行分布式事务的过程使用两阶段提交，发生时间在由分布式事务的各个分支需要进行的西东已经被执行：
- 阶段 1：所有分支预备好。即它们被 TM 告知要准备提交
- 阶段 2：TM 告知 RMs 是否要提交或者回滚。

#### 4.2 分布式事务使用
```
终端 1：                                             终端 2：
---------------------------------------------------------------------------------------------------------

步骤 1：分别启动分布式事务中的一个分支事务，test 为 gtrid，db1 和 db2 位bqual
xa start 'test', 'db1';                             xa start 'test', 'db2';
insert into user(name) values('zs');                update order set last_update=now() where oid=3;
---------------------------------------------------------------------------------------------------------

步骤 2：分别对事务进行第一阶段提交，进入 prepare 状态
xa end 'test', 'db1';                               xa end 'test', 'db2';
---------------------------------------------------------------------------------------------------------

步骤 3：查看当前分支状态
xa recover;                                         xa recover;
---------------------------------------------------------------------------------------------------------

步骤 4：分别提交各自的分支事务
xa commit 'test', 'db1';                            xa commit 'test', 'db2';
---------------------------------------------------------------------------------------------------------
```

#### 4.3 MySQL 分布式的隐患
如果分支事务达到 prepare 状态时，数据库异常重新启动，此时仍然可以对分支事务进行提交、回滚，但是提交的事务没有写 binlog，存在隐患：使用 binlog 恢复时可能会丢失数据，也会引起主从数据不一致。  

