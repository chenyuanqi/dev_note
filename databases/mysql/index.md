
### Mysql 索引
索引是一种特殊的文件,它们包含着对数据表里所有记录的引用指针，相当于书本的目录。其作用就是加快数据的检索效率。  

- 索引优点
> 快速访问数据表中的特定信息，提高检索速度。  
> 创建唯一性索引，保证数据表中每一行数据的唯一性。  
> 加速表与表之间的连接。  
> 使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间。  

- 索引缺点
> 虽然提高了的查询速度，但却降低了更新表的速度，比如 update、insert，因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；  
> 建立索引会占用磁盘文件的索引文件。  

### Mysql 索引类型
索引有很多的类型，都是实现在存储引擎层的。  

按照逻辑分类，索引可分为普通索引、唯一索引、主键索引、复合（组合）索引、外键索引、前缀索引和全文索引。  
普通索引，最基本的索引，没有任何约束限制。  
唯一索引，与普通索引类似，但是具有唯一性约束 （一个表可以有多个唯一索引）。  
主键索引，特殊的唯一索引，不允许有空值（一个表只能有一个主键索引， 主键还可以与外键构成参照完整性约束）。  
组合索引，将多个列组合在一起创建索引，可以覆盖多个列。  
> 用于多字段查询，比如，建了一个 key (a,b,c) 的联合索引，那么实际等于建了 key (a)、key (a,b)、key (a,b,c) 等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；  
> 覆盖索引，比如，对于联合索引 key (a,b,c) 来说，如果使用 SQL：select a,b,c from table where a=1 and b = 1 ，就可以直接通过遍历索引取得数据，而无需回表查询，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；  
> 索引列越多，通过索引筛选出的数据越少。  

外键索引，只有 InnoDB 类型的表才能使用外键索引，保证数据的一致性，完整性和实现级联操作。  
前缀索引，也叫局部索引，比如给身份证的前 6 位添加索引（在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，我们可以使用身份证倒序存储，或者使用 hash 值）。  
> 当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引。  
> 前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。  
> 前缀索引不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。  

全文索引，只能对英文进行全文检索，mysql 5.6 版本以前只能由于 MyISAM，5.6 版本以后 InnoDB 也可以使用。 
```mysql
-- 创建主键索引
alter table t add primary key add(`id`);
-- 创建唯一索引
alter table t add unique(`username`);
-- 创建普通索引
alter table t add index index_name(`username`);
-- 创建全文索引
alter table t add fulltext(`username`);
```

按照物理分类，索引可分为聚簇索引、非聚簇索引。  
聚簇索引，一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的 6 字节 ROWID 作为聚簇索引。每张表只有一个聚簇索引，因为聚簇索引的键值的逻辑顺序决定了表中相应行的物理顺序。聚簇索引在精确查找和范围查找方面有良好的性能表现（相比于普通索引和全表扫描），聚簇索引就显得弥足珍贵，聚簇索引选择还是要慎重的（一般不会让没有语义的自增 id 充当聚簇索引）。  
非聚簇索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（非主键的那一列），一个表中可以拥有多个非聚集索引。  

### 索引对性能的影响
> 大大减少服务器对数据的扫描量。  
> 帮助服务器避免排序和临时表。  
> 将随机 IO 变成顺序 IO。  
> 大大提高查询速率，但会降低写的速度（因为在对数据库进行写操作时，会额外的再操作一遍索引），并占用磁盘（因为索引本身也是一种数据）。

### Mysql 索引原则
索引的使用场景
> 对于非常小的表（比如只有几十个固定数据的表）来说，大部分情况下不使用索引，全盘扫描效率可能会更高。
> 中到大型表，索引非常有效。  
> 特大型的表，建立和使用索引的代价会随之增加，可以使用分区技术来解决。  

索引创建的原则
> 最左前缀原理  
> 尽量的去扩展索引，而不是重复的新建新索引  
> 最适合索引的列是出现在 WHERE 子句当中的列或连接子句中的列，而不是出现在SELECT关键字后的列。  
> 索引列的基数越大，索引的效果越好。  
> 对字符串进行索引，应制定一个前缀长度，可以节省大量的索引空间。  
> 根据情况创建复合索引，复合索引可以提高查询效率。  
> 避免创建过多的索引，索引会额外的占用磁盘空间，降低写操作效率。  
> 主键尽可能选择较短的数据类型，可以有效的减少索引的磁盘占用，提高查询效率。  

### 索引的常见存储算法
- 哈希存储法：以 key、value 方式存储，把值存入数组中使用哈希值确认数据的位置，如果发生哈希冲突，使用链表存储数据；
- 有序数组存储法：按顺序存储，优点是可以使用二分法快速找到数据，缺点是更新效率，适合静态数据存储；
- 搜索树：以树的方式进行存储，查询性能好，更新速度快。

### 索引的注意事项
> 复合索引遵循最左前缀原则。  
> like 查询，% 号不能在前，可以考虑使用全文索引。  
> column is null 可以使用索引。  
> 如果 mysql 自我评估使用索引比全文扫描更加慢，会放弃使用索引。  
> 如果 or 前的条件中有列的索引，后面的没有，索引都不会被用到（or 查询会使 MySQL 放弃索引而全表扫描，可以考虑 union 联合查询）。  
> 列类型是字符串的话，查询时一定要给值加引号，否则索引失效。  

### 常见问题
1、主键索引和唯一索引有什么区别？  
> 主键索引不能重复且不能为空，唯一索引不能重复，但可以为空；  
> 一张表只能有一个主键索引，但可以有多个唯一索引；  
> 主键索引的查询性能要高于唯一索引（主键查询 select * from t where id=10 只需要搜索 id 的这棵 B+ 树，而普通索引查询 select * from t where f=3 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。）。  

2、如何查询一张表的所有索引？  
```mysql
SHOW INDEX FROM table_name;
```

3、MySQL 最多可以创建多少个索引列？  
16 个。  

4、如何让 like %abc 走索引查询？  
```mysql
select * from table_name where reverse(f) like reverse('%abc');
```

5、如何解决 MySQL 错选索引的问题？  
> MySQL 会错选索引，比如 k 索引的速度更快，但是 MySQL 并没有使用而是采用了 v 索引，这种就叫错选索引，因为索引选择是 MySQL 的服务层的优化器来自动选择的，但它在复杂情况下也和人写程序一样出现缺陷。  
> 这样，我们可以采取如下措施：  
> 删除错选的索引，只留下对的索引；  
> 使用 force index 指定索引，比如 select * from t force index(index_t)；  
> 查询时指定使用索引，比如 select f from t use index(dg) where day='2010-12-31' and group=18 and begintime< '2019-12-31 12:14:28' order by begintime limit 1;  
> 修改 SQL 查询语句引导 MySQL 使用我们期望的索引，比如把 order by b limit 1 改为 order by b,a limit 1 语义是相同的，但 MySQL 查询的时候会考虑使用 a 键上的索引。  

6、优化器选择查询索引的影响因素有哪些？  
> 优化器的目的是使用最小的代价选择最优的执行方案，影响优化器选择索引的因素如下：  
> 扫描行数，扫描的行数越少，执行代价就越少，执行效率就会越高；  
> 是否使用了临时表；  
> 是否排序。  

7、MySQL 是如何判断索引扫描行数的多少？  
> MySQL 的扫描行数是通过索引统计列（cardinality）大致得到并且判断的，而索引统计列（cardinality）可以通过查询命令 show index 得到，索引扫描行数的多少就是通过这个值进行判断的。  

8、MySQL 是如何得到索引基数的？它准确吗？  
> MySQL 的索引基数并不准确，因为 MySQL 的索引基数是通过采样统计得到的，比如 InnoDb 默认会有 N 个数据页，采样统计会统计这些页面上的不同值得到一个平均值，然后除以这个索引的页面数就得到了这个索引基数。  
