
### 本地事务
事务，其实是包含一系列操作的、一个有边界的工作序列，有明确的开始和结束标志，且要么被完全执行，要么完全失败，即 all or nothing。通常情况下，我们所说的事务指的都是本地事务，也就是在单机上的事务。  
本地事务是特定于资源的，比如一个本地事务是与一个具体 JDBC 数据库连接相关的，一个本地事务关联一个数据库连接。

### 分布式事务
分布式事务，就是在分布式系统中运行的事务，由多个本地事务组合而成。在分布式场景下，对事务的处理操作可能来自不同的机器，甚至是来自不同的操作系统。  

要深入理解分布式事务，我们首先需要了解它的特征。分布式事务是多个事务的组合，那么事务的特征 ACID，也是分布式事务的基本特征，其中 ACID 具体含义如下：  

- 原子性（Atomicity），即事务最终的状态只有两种，全部执行成功和全部不执行。若处理事务的任何一项操作不成功，就会导致整个事务失败。一旦操作失败，所有操作都会被取消（即回滚），使得事务仿佛没有被执行过一样。  
- 一致性（Consistency），是指事务操作前和操作后，数据的完整性保持一致或满足完整性约束。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元 ; 一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况 (该情况，用户 A 和 B 均为 600 元，总共 1200 元)。  
- 隔离性（Isolation），是指当系统内有多个事务并发执行时，多个事务不会相互干扰，即一个事务内部的操作及使用的数据，对其他并发事务是隔离的。  
- 持久性（Durability），也被称为永久性，是指一个事务完成了，那么它对数据库所做的更新就被永久保存下来了。即使发生系统崩溃或宕机等故障，只要数据库能够重新被访问，那么一定能够将其恢复到事务完成时的状态。

分布式事务基本能够满足 ACID，其中的 C 是强一致性，也就是所有操作均执行成功，才提交最终结果，以保证数据一致性或完整性。但随着分布式系统规模不断扩大，复杂度急剧上升，达成强一致性所需时间周期较长，限定了复杂业务的处理。为了适应复杂业务，出现了 BASE 理论，该理论的一个关键点就是采用最终一致性代替强一致性。  

分布式事务主要是解决在分布式环境下，组合事务的一致性问题。实现分布式事务有以下 3 种基本方法：  

- 基于 XA 协议的二阶段提交协议方法；  
- 三阶段提交协议方法；  
- 基于消息的最终一致性方法。  

### 分布式事务之二阶段提交协议（2PC）
在二阶段提交协议中，分布式事务由事务发起者、资源管理器（参与者）、事务协调者组成。  
1、分布式事务由方向事务协调器发起分布式事务，协调器则向所有事务参与者发起准备请求，事务参与者接受到请求后，执行本地事务，但是不提交。如果所有事务参与者都返回了准备 OK 到事务协调器，则事务协调器准备进入第二阶段；如果有一个参与者返回准备失败或者协调器等待超时后还没有收到参与者的反馈，则事务协调器向所有参与者发起事务回滚请求，事务参与者收到请求后回滚执行的本地事务，然后分布式事务结束。  
2、事务协调器向所有事务参与者发起提交事务的请求，事务参与者接受到请求后，执行本地事务的提交操作，执行完毕后释放事务对应的锁和其它资源。如果事务协调器收到所有参与者提交 OK 则分布式事务结束。  

二阶段协议是个标准协议，协议只是规定了分布式事务使用两阶段来做，其中第一步可以认为是投票，第二阶段认为是做决策。  
由于第二步要么全部提交要么全部回滚，所以可以认为二阶段协议是强一致性协议。  

二阶段是一个比较经典的实现分布式事务原子性的协议，目前分布式事务实现上大多都是使用二阶段协议来实现的。但是，二阶段协议存在一个同步阻塞的问题：在第一阶段所有参与者接受到事务协调器的事务准备请求后，会在本地开启并执行事务，但是没有提交事务；所有参与者等待第二阶段事务协调器发出事务提交或者回滚后才会提交或者回滚事务；而在这期间所有参与者开启的本地事务一直存在，也就是一直把相应的资源锁定了，导致其他需要访问这行数据的事务阻塞等待。

### 分布式事务之三阶段提交协议（3PC）
三阶段协议把二阶段的第一阶段在细分为 2 阶段，相比二阶段是阻塞协议，三阶段是非阻塞协议。  
对应事务协调器来说，接受到一个分布式事务请求后，会向所有事务参与者发起 canCommit 请求，然后协调器处于 waiting 状态。如果协调器收到参与者反馈的 NO 消息，或者等待超时没有收到参与者的反馈，则协调器向所有参与者发起 abort 请求，分布式事务异常结束；否则，如果协调器在超时时间窗口到达前收到了所有参与者的反馈的 YES 消息，则协调器向所有参与者发送 preCommit 消息，然后协调器处于 prepared 状态。如果协调器收到了所有参与者返回的 ACK 消息，则协调器状态从 prepared 转换到 commit 待提交状态，然后向所有参与者发起 doCommit 请求；否则，如果协调器等待超时还没有收到参与者的返回或者有些参与者返回了 NO，则协调器向所有参与者发起回滚请求，然后协调器处于 Done 状态。如果协调器收到了所有参与者返回的 havaCommitted 消息则协调器状态转换为 done, 分布式事务正常结束。如果协调器收到参与者返回的 NO 信息或者没有收到参与者反馈，则向所有参与者发起回滚请求。  

对应参与者来说，第一阶段如果参与者接受到协调器发来的 canCommitted 请求，如果参与者接受该请求，则向协调器发送 YES 反馈，然后状态转换到 prepared；如果参与者不接受该请求，则向协调器发送 NO 消息，然后自己处于 abort 状态。如果参与者一直没有收到 preCommited 请求，则超时后会处于 abort 状态。如果参与者接受到了协调器发来的 abort 请求，则参与者也处于 abort 请求。  
第二阶段如果参与者收到协调器发来的 preCommit 请求，执行 OK 后会发送 ACk 到协调器，然后等待最终的提交或者回滚。如果参与者接受到 preCommit 请求后协调器挂了或者参与者等待超时都没收到协调器发来的提交或者回滚请求，则参与者默认执行自动提交。  
第三阶段如果参与者接受到了协调器发来的 doCommit 请求，则参与者会执行具体提交，然后返回 havaCommitted 信息。  

在提交阶段，二阶段提交协议无法可靠地从协调器和参与者的故障中恢复。如果只有协调器挂了，并且所有参与者没有收到提交消息，这时候根据参与者的状态可以判断出参与者没有执行提交，新选取的协调器发送提交命令到参与者就可以恢复了。但是，如果协调器和一部分参与者都挂了，则挂掉的参与者可能是第一个被通知提交的，并且实际上已经完成了提交，则这时候即使选择了新的协调器，协调器由于已经处于 commit 状态了，则必须阻塞直到所有参与者给予了反馈，而之前的参与者已经完成了提交，不会在给协调器发送回执了。  
三阶段提交协议通过引入 Prepared to commit（第二阶段）状态来消除此问题。如果协调器在发送 preCommited 消息之前挂了，则参与者将一致同意该操作被中止（协调器超时后会发送 abort 命令，参与者超时后会处于 abort 状态），这时候分布式事务就结束了，并且没有占用任何资源。并且在所有参与者确认他们准备提交之前，协调器不会发出 doCommit 消息。如果在协调器发送 doCommit 消息后，协调器挂了，则参与者在超时后会自动提交。新选择出来的协调器在等待超时后也会发送回滚信息到参与者，而不会一直等待。  

但是，三阶段协议也会存在数据不一致性问题，比如由于网络原因，协调器发送的 abort 响应没有及时被参与者接收到，而参与者在等待超时之后执行了 commit 操作，而其它参与者接受到了 abort 命令执行了回滚，这时候数据就处于不一致状态了。  
所以，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。于是，公认为难于理解但是行之有效的 Paxos 算法。  

### 基于分布式消息的最终一致性方案
2PC 和 3PC 这两种方法，有两个共同的缺点，一是都需要锁定资源，降低系统性能；二是，没有解决数据不一致的问题。因此，便有了通过分布式消息来确保事务最终一致性的方案。  
将需要分布式处理的事务通过消息或者日志的方式异步执行，消息或日志可以存到本地文件、数据库或消息队列中，再通过业务规则进行失败重试。这就是使用基于分布式消息的最终一致性方案解决了分布式事务的问题。   
基于分布式消息的最终一致性方案的事务处理，引入了一个消息中间件（Message Queue，MQ），用于在多个应用之间进行消息传递。  
