
### 数据结构 - 哈希（散列）
散列表（HashTable，也叫哈希表），是根据键（Key）直接访问在内存存储位置的数据结构。  

实现原理是：通过散列函数（也叫哈希函数）将元素的键映射为数组下标（转化后的值叫做散列值或哈希值），然后在对应下标位置存储记录值。当我们按照键值查询元素时，就是用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。  

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。  

散列表中有两个关键的概念，一个是散列函数（或者哈希函数），一个是散列冲突（或者哈希冲突）。  
散列函数用于将键值经过处理后转化为散列值。具有以下特性：  
- 散列函数计算得到的散列值是非负整数  
- 如果 key1 == key2，则 hash(key1) == hash(key2)  
- 如果 key1 != key2，则 hash(key1) != hash(key2)  
所谓散列冲突，指的是 key1 != key2 的情况下，通过散列函数处理，hash(key1) == hash(key2)。设计再好的散列函数也无法避免散列冲突，原因是散列值是非负整数，总量是有限的，但是现实世界中要处理的键值是无限的，将无限的数据映射到有限的集合，肯定避免不了冲突。  

### 散列冲突
常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。  

开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。  
如何重新探测新的位置呢？一个比较简单的探测方法，线性探测（Linear Probing） —— 当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置（遍历到尾部都没有找到空闲的位置，再从表头开始找），直到找到为止。  
开放寻址法，优点：  
- 不需要额外空间  
- 有效利用 CPU 缓存  
- 方便序列化  
开放寻址法，缺点：  
- 查找、删除数据时，涉及到 delete 标志，相对麻烦  
- 冲突的代价更高  
- 对装载因子敏感  

链表法是一种更加常用的散列冲突解决办法。在散列表中，每个 “桶（bucket）” 或者 “槽（slot）” 会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。
链表法，优点：  
- 内存利用率较高 —— 链表的优点  
- 对装载因子不敏感  
链表法，缺点：  
- 需要额外的空间（保存指针）  
- 对 CPU 缓存不友好  

