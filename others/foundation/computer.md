
### 计算机组成
**计算机工作流程**  
数据经过输入单元输入到内存里，cpu 读取内存数据，进行处理后，写入内存，然后传给输出单元或者存储在本地硬盘里。  

**冯・诺依曼体系结构**  
1、计算机处理的数据和指令一律用二进制数表示  
2、顺序执行程序  
计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序从主存储器中取出指令一条一条地执行，这一概念称作顺序执行程序  
3、计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成  

**二进制**  
1、机器数  
由于计算机中符号和数字一样，都必须用二进制数串来表示，因此，正负号也必须用 0 和 1 来表示。  
用最高位 0 表示正、1 表示负，这种正负号数字化的机内表示形式就称为 “机器数”, 而相应的机器外部用正负号表示的数称为 “真值”, 将一个真值表示成二进制字串的机器数的过程就称为编码。  
2、原码  
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。原码是人脑最容易理解和计算的表示方式。  
比如 8 位的二进制:  
[+1] 原 = 0000 0001  
[-1] 原 = 1000 0001  
因为第一位是符号位，所以 8 位二进制数的取值范围就是:  
[1111 1111 , 0111 1111]  
[-127 , 127]  
3、反码  
反码的表示方法是: 正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。  
如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。  
比如 8 位的二进制：  
[+1] = [00000001] 原 = [00000001] 反  
[-1] = [10000001] 原 = [11111110] 反  
4、补码  
补码的表示方法是: 正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 + 1 (即在反码的基础上 + 1)。  
对于负数，补码的表示方式也是人脑无法直观看出其数值的。  
比如 8 位的二进制:  
[+1] = [00000001] 原 = [00000001] 反 = [00000001] 补  
[-1] = [10000001] 原 = [11111110] 反 = [11111111] 补  
5、定点数与浮点数  
定点数是小数点固定的数。  
在计算机中没有专门表示小数点的位，小数点的位置是约定默认的。一般固定在机器数的最低位之后（定点纯整数），或是固定在符号位之后（定点纯小数）。  
定点数表示法简单直观，但是数值表示的范围太小，运算时容易产生溢出。  
浮点数是小数点的位置可以变动的数。  
为增大数值表示范围，防止溢出，采用浮点数表示法（类似十进制中的科学计数法）。  
在计算机中通常把浮点数分成阶码和尾数两部分来表示，其中阶码一般用补码定点整数表示，尾数一般用补码或原码定点小数表示。为保证不损失有效数字，对尾数进行规格化处理，也就是平时所说的科学记数法，即保证尾数的最高位为 1，实际数值通过阶码进行调整。  
阶符表示指数的符号位、阶码表示幂次、数符表示尾数的符号位、尾数表示规格化后的小数值（N = 尾数×基数阶码（指数））。  
`为什么有了原码，还需要反码和补码呢？主要是使得计算机学会像人一样去运算`  
[关于原码反码补码的参考](https://www.zhihu.com/question/20159860)   

**计算机单位**  
1、位 (bit) 是电子计算机中最小的数据单位，每一位的状态只能是 0 或 1。  
2、8 个二进制位构成 1 个字节 (Byte)，它是存储空间的基本计量单位。1 个字节可以储存 1 个英文字母或者半个汉字，换句话说，1 个汉字占据 2 个字节的存储空间。  
3、字（word）由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。例如一台 8 位机，它的 1 个字就等于 1 个字节，字长为 8 位；如果是一台 16 位机，那么，它的 1 个字就由 2 个字节构成，字长为 16 位。字是计算机进行数据处理和运算的单位。  
`为什么 100M 的宽带，理论最高下载速度只有 12.5M 而不是 100M？因为宽带和传输速度用的单位不一样，100M bit = 100M /8 = 12.5M Byte。那硬盘标注 500GB，为什么使用时最大容量比标注的少？因为厂商标注容量时使用的是十进制，而计算机使用的是二进制。`

**字节序**  
字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。  
小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处。  
基于 X86 平台的 PC 机是小端字节序的，而有的嵌入式平台则是大端字节序的。所有网络协议也都是采用 big endian 的方式来传输数据的，所以有时我们也会把 big endian 方式称之为网络字节序。  

**字节对齐**  
现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。  
为什么要进行字节对齐？  
1、某些平台只能在特定的地址处访问特定类型的数据；  
2、最根本的原因是效率问题，字节对齐能提⾼存取数据的速度。  
比如有的平台每次都是从偶地址处读取数据，对于一个 int 型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量，但是若从奇地址单元处存放，则需要 2 个读取周期读取该变量。

**计算机架构和接口设备**  
主板上有 2 个桥接器，北桥连接 cpu、内存、显卡，南桥连接硬盘、USB、网卡等。  
1、cpu  
cpu 有 2 个主要单元：算数逻辑单元（负责程序运算和逻辑控制）和控制单元（协调各组件与各单元间的工作）。  
决定 cpu 性能的因素：指令集和频率 (即每秒可以进行的工作次数，频率分外频和倍频，二者相乘才是 cpu 的频率) 。  
cpu 每次能处理的数据量称为字组大小，如果一次能处理 32 位的数据，就称该 cpu 是 32 位的，能处理 64bit 即 64 位的 cpu。  
`为什么使用 32 位 cpu 的系统，最大只能使用 4GB 内存？因为 32 位 cpu 通常只有 32 条地址总线，能找到的内存物理地址数是 2 的 32 次幂，而每个内存物理地址对应的是 1Bit 的大小，所以 32 位系统只能支持最大 2 的 32 次幂 * 1Bit 的内存容量 ，即 4GB 大小的内存`   
2、内存  
cpu 所有数据都来自内存。  
内存的主要组成部分是动态随机访问内存 (D・RAM)，通电时才能使用，断电后数据消失。  
内存容量越大越好，因为所有数据都要加载到内存里才能被 cpu 读取；如果现在要加载大量数据到内存里，如果内存没有足够容量就只能释放暂时不用的内存， 
而释放内存可能会消耗一定的 cpu 时间，导致系统卡顿。  
内存频率最好和所使用的 cpu 的外频一样。  
cpu 的数据是通过北桥从内存里读出来的，如果不通过北桥直接在 cpu 内部读取就会快很多，因此有了 cpu 高速缓存。由于高速缓存在 cpu 内，要与 cpu 总体工作频率一致，D・RAM 不支持，需要静态随机访问内存 (S・RAM)。  
BIOS（基础输入输出系统）是个程序，管理系统信息、进行开机自检等功能。bios 程序写死在在主板的一个内存芯片里 (ROM)，ROM 芯片没有通电也能记录数据 (相当于硬盘)。  
CMOS 芯片是一个主板上的可读写的 RAM 芯片 (RAM 断电数据消失，所以 CMOS 有单独的电池)。这个芯片记录了硬件的各项参数，CMOS 的设置通常被写进 BIOS 里。  

**文件编码**  
计算机只会使用 0/1 记录数据，所以写入数据时，会把字码根据字码对照表 (编码系统) 转换为 0/1 再存入文件；
同理，读取文件时，也是读取一堆 0/1 数据，转换为字码后，展示到屏幕上。  
常用的编码表是 ASCII 码，每个符号 (英文、数字、符号) 占用 1B (8bit)，总共会有 2 的 8 次幂种组合，所以这种编码只支持 256 个字符。中文用的最多的编码系统是 GBK，是对 ASCII 码的扩展；GBK 会有 2 的 16 次幂 = 65532 种组合，理论可以表示 6 万多个中文。  
但是各国的文字都不一样，为了统一编码，出现了全球统一编码 Unicode 编码，日常使用 UTF-8。  

### 操作系统
**进程和线程**  
进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位；进程拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。
线程：一个进程内的基本调度单位。线程的划分尺度小于进程，一个进程包含一个或者更多的线程；每一个独立的线程，都有一个程序运行的入口、顺序执行序列、和程序的出口，但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。多线程的意义在于一个应用程序中，有多个执行部分可以同时执行，但是操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。  

进程 (process) 与线程 (thread) 最大的区别是进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程 A 不能通过传地址的方式直接读写进程 B 的存储区域。进程之间的通信需要通过进程间通信 (Inter-process communication，IPC)。与之相对的，同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息。  

进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。  

线程可以分为两类：  
一类是用户级线程 (user level thread)。对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。 用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。  
另一类是内核级线程 (kernel level thread)。对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的 CPU，以实现真正的并行计算。  
事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。  

**进程间通信方式**  
1、管道  
管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。  
写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。  
无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系（通常是指父子进程关系）的进程间使用。  
命名管道：命名管道也是半双工的通信方式，在文件系统中作为一个特殊的设备文件而存在，但是它允许无亲缘关系进程间的通信。当共享管道的进程执行完所有的 I/O 操作以后，命名管道将继续保存在文件系统中以便以后使用。  
2、信号量  
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。  
3、消息队列  
消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。  
4、信号  
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。  
5、共享内存  
共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。  
6、套接字  
套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。  

**协程**  
协程，又称微线程，纤程，英文名 Coroutine。  
协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时协程也失去了标准线程使用多 CPU 的能力。  

**上下文切换**  
对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。  
上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。  
从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。  

**系统调用**  
系统调用 (System call) 是程序向系统内核请求服务的方式。  
系统调用包括硬件相关的服务（比如访问硬盘等）或者创建新进程，调度其他进程等。  
系统调用是程序和操作系统之间的重要接口。  

**IO 多路复用**  
IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 条件准备读取，它就通知该进程。  
IO 多路复用适用如下场合：  
1、当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用 I/O 复用。  
2、当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。  
3、如果一个 TCP 服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到 I/O 复用。  
4、如果一个服务器即要处理 TCP，又要处理 UDP，一般要使用 I/O 复用。  
5、如果一个服务器要处理多个服务或多个协议，一般要使用 I/O 复用。  
与多进程和多线程技术相比，I/O 多路复用技术的最大优势是系统开销小，系统不必创建进程 / 线程，也不必维护这些进程 / 线程，从而大大减小了系统的开销。

**Semaphore/Mutex**  
当用户创立多个线程／进程时，如果不同线程／进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制核心区域 (critical section) 的访问权限。  
对于 semaphore 而言，在初始化变量的时候可以控制允许多少个线程／进程同时访问一个核心区域，其他的线程／进程会被堵塞，直到有人解锁。  
Mutex 相当于只允许一个线程／进程访问的 semaphore。此外，根据实际需要，人们还实现了一种读写锁 (read-write lock)，它允许同时存在多个阅读者 (reader)，但任何时候至多只有一个写者 (writer)，且不能于读者共存。  

**死锁**  
在引入锁的同时，我们遇到了一个新的问题：死锁 (Deadlock)。  
死锁是指两个或多个线程／进程之间相互阻塞，以至于任何一个都不能继续运行，因此也不能解锁其他线程／进程。例如线程 A 占有 lock A，并且尝试获取 lock B；而线程 2 占有 lock B，尝试获取 lock A。此时，两者相互阻塞，都无法继续运行。  

产生死锁的四个条件 (只有当四个条件同时满足时才会产生死锁)：  
1、互斥：资源不能被共享，只能由一个进程使用。  
2、请求与保持条件 (Hold and wait)：占有并等待一个进程因请求资源而阻塞时，对已获得的资源保持不放。  
3、非剥夺/不可抢占条件 (No pre-emption)：已经分配的资源在未使用完之前不能从相应的进程中被强制地剥夺。  
4、循环等待条件 (Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源，进程之间形成一种首尾相接的循环等待资源关系。  

如何处理死锁问题：  
1、忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧，跟掩耳盗铃有点像。  
2、检测死锁并且恢复。  
3、仔细地对资源进行动态分配，以避免死锁。  
4、通过破除死锁四个必要条件之一，来防止死锁产生。  

### 补充说明
**位运算**  
位运算分为 6 种，它们是：按位与 &，按位或 \，按位异或 ^，按位取反 ~，左移运算 <<，右移运算 >>。  

按位与运算将参与运算的两数对应的二进制位相与，当对应的二进制位均为 1 时，结果位为 1，否则结果位为 0。  
按位或运算将参与运算的两数对应的二进制位相或，只要对应的二进制位中有 1，结果位为 1，否则结果位为 0。  
按位异或运算将参与运算的两数对应的二进制位相异或，当对应的二进制位值不同时，结果位为 1，否则结果位为 0。  
按位取反运算将二进制数的每一个位上面的 0 换成 1，1 换成 0。  
左移运算将数对应的二进位全部向左移动若干位，高位丢弃，低位补 0。  
右移运算将数对应的二进位全部向右移动若干位。对于左边的空位，如果是正数则补 0，负数可能补 0 或 1 （Turbo C 和很多编译器选择补 1）。  
`注意：参与运算的数都以补码方式出现。`
```
# 按位取反
~x = -(x+1)

# 左移 n 位，翻 2 的 n 次幂
x<<n = x*power(2, n)

# 右移 n 位，除 2 的 n 次幂
x>>n = x÷power(2, n)
```
位运算的应用  
```python
# 判断数字奇偶
# 因为奇数的二进制最低位始终为 1，而偶数的二进制最低为始终为 0
if number & 1:
    print('奇数')
else:
    print('偶数')

# 实现变量交换
a = a^b; # 获得 a 和 b 的异或数 x
b = a^b; # 异或数 x 与 b 异或获得原来的 a
a = a^b; # 异或数 x 与原来的 a 异或获得原来的 b
```

**余数**  
整数是没有边界的，它可能是正无穷，也可能是负无穷。余数却总是在一个固定的范围内，比如你拿任何一个整数除以 7，那得到的余数肯定是在 0～6 之间的某一个数。生活中，余数可以用来算星期，web 编程中可以用在分页中。

同余定理：两个整数 a 和 b，如果它们除以正整数 m 得到的余数相等，我们就可以说 a 和 b 对于模 m 同余。  

哈希有的时候也会被翻译为散列，简单来说，它就是将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出。假如你想要快速读写 100 万条数据记录，要达到高速地存取，理想的情况当 然是开辟一个连续的空间存放这些数据，这样就可以减少寻址的时间。但是由于条件的限 制，我们并没有能够容纳 100 万条记录的连续地址空间。  
通过余数，你就能将任何数值，转换为有限范围内的一个数值，然后根据这个 新的数值，来确定将数据存放在何处。具体而言，通过记录标号模 100 的余数，指定某条记录存放在哪个空间，公式是 f(x) = x mod 100。假设有两条记录，它们的记录标号分别是 1 和 101，我们把这些模 100 之后余数都是 1 的，存放到第 1 个可用空间里，以此类推，我们就可以根据求余的快速数字变化，对数据进行分组，并把它们存放到不同的地 址空间里。而且，求余操作本身非常简单，因此几乎不会增加寻址时间。  
