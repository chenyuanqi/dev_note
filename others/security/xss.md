
### 什么是 XSS 攻击
跨站脚本攻击， XSS 攻击是 Web 攻击中最常见的攻击方法之一，它是通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的，形成了一次有效 XSS 攻击，一旦攻击成功，它可以获取用户的联系人列表，然后向联系人发送虚假诈骗信息，可以删除用户的日志等等，有时候还和其他攻击方式同时实施比如 SQL 注入攻击服务器和数据库、Click 劫持、相对链接劫持等实施钓鱼，它带来的危害是巨大的，是 web 安全的头号大敌。

跨站脚本的重点不在 “跨站” 上，而应该在 “脚本” 上... 因为这个 “跨” 实际上属于浏览器的特性，而不是缺陷，造成 “跨” 的假象是因为绝大多数的 XSS 攻击都会采用嵌入一段远程或者说第三方域上的脚本资源。  

攻击者一般通过 script 标签对网站注入一些可执行的代码，这样就可以很轻松的获取到用户的一些信息。  

### XSS 可以带来哪些危害
对于 XSS 攻击的危害，大多数的人们却没有正确的认识，实际上攻击者可以利用 XSS 攻击造成巨大的危害。比如：  
网页挂马；  
盗取 Cookie;  
DoS 攻击；  
钓鱼攻击；  
蠕虫攻击；  
劫持用户 web 行为；  
结合 CSRF 进行针对性攻击；  
······  
这些都是可以利用 XSS 漏洞来达成的。  

### XSS 类型
目前的 XSS 总共可以分为三种类型：反射型 (也叫非持久型)、存储型 (也叫持久型)、DOM 型。「前两种 XSS 都会与服务器产生交互，后一种不会产生交互」  

反射型 XSS，也称非持久型 XSS，最常见也是使用最广的一种。在反射型 XSS 中，payload 一般存在于网页的 Url 中，只用户单击时触发，只执行一次，非持久化，故称反射型 XSS。攻击者发送恶意 Url 链接让受害者点击 (一般会对 payload 部分进行处理，如：编码转换和短域名跳转)。  
有人认为反射型 XSS 需要用户已经登陆的情况下才能利用，其实不然。我们可以通过反射型 xss 让浏览器远程嵌入我们的 js 文件，然后配合浏览器漏洞进行 RCE 攻击。这里给出个相近的例子：[《记一次从 DOM 型 XSS 到 RCE 过程》](https://xz.aliyun.com/t/3919)  
存储型 XSS，也称持久型 XSS，攻击者首先将恶意 javascript 代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意 javascript 页面就会执行恶意代码，不需要用户点击特定 Url 就能执行，故存储型 XSS 比反射型 XSS 更具威胁性。  
存储型 XSS 与反射型 XSS 最大的区别就在于提交的 XSS 代码会储存于服务端，下次再访问目标页面时不用再提交 XSS 代码。  

DOM 是 Document Object Model (文件对象模型) 的缩写。  
客户端 javascipt 是可以访问浏览器的 DOM 文本对象模型，如果没有经过适当的过滤和消毒，那么应用程序可能会受到基于 DOM 的 XSS 攻击。  
通过修改页面的 DOM 节点形成的 XSS，称之为 DOM Based XSS，也就是 DOM 型 XSS。  

### XSS 的利用方式
- Cookie 窃取
> Cookie 盗取是 xss 攻击中最实用也是最广泛的一种利用方式之一。  
> Cookie 是 Web 系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。  
> 同时，对于 cookie 的操作十分的方便，我们可以通过 Document 对象访问 Cookie。如：<script>alert(document.cookie)</script>会弹出当前页面的 cookie 信息。  
> 
> Cookie 也可以安装类型分为：  
> 本地 Cookie———— 即储存在计算机硬盘中，关闭浏览器后依旧存在；  
> 内存 Cookie———— 即储存在内存中，随浏览器的关闭而消失；  
> 区分两者很简单，只要判断 cookie 中的 expires 即过期时间属性有没有设置，如果设置了即为本地 cookie，反之为内存 cookie。  

- 会话劫持
> 由于 Cookie 的不安全性，开发者们开始使用一些更为安全的认证方式 —— Session。  
> Session 的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的 Session。Session 是给予访问的进程，记录了一个访问的开始到结束，搭档浏览器或进程关闭之后，Session 也就 “消失” 了。   
> 在 Session 机制中，客户端和服务端也有被其他人利用的可能。    
> Session 和 Cookie 最大的区别在于：Session 是保存在服务端的内存里面，而 Cookie 保存于浏览器或客户端文件里面。  
> 会话劫持的实质就是模拟 GET/POST 请求 (带 Cookie) 通过受害者浏览器发送给服务器，我们可以通过下面的方式来完成。  
> 我们可以通过构造的 GET/POST 请求来实现如添加管理员、删除文章、上传文件等操作。XSS 蠕虫从某种意义上来说也属于会话劫持。

- 钓鱼 
> XSS 重定向钓鱼：从www.a.com通过 xss 漏洞跳转到www.b.com的钓鱼页面上，整个过程变化明显，受害者易察觉。  
> HTML 注入式钓鱼：通过 javascript 来修改页面的 DOM 对象属性，或在原页面中添加新的 DOM 元素。前者相对于后者更隐蔽。  
> Iframe：攻击者通过 javascript 来添加一个新的<Iframe>标签嵌入第三方域的内容 (钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。  

### XSS 漏洞的挖掘
XSS 漏洞的挖掘主要分为白盒审计和黑盒 Fuzz 两种。  

- 白盒审计
> 通过查看源代码来判断网站的交互点是否存在安全过滤。  
> 分析源代码挖掘 XSS 的一般思路是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被 htmlencode () 之类的函数过滤。  
> 

- 黑盒 Fuzz
> XSS 黑盒测试时主要分为手工检测和工具检测。  
> 手工检测：首先我们需要尽可能地找到目标的每个输入输出点并挨个尝试；在进行尝试的时候，我们应优先选择特殊字符进行测试，如"<>&;/':等，如果连<>都未过滤 / 转义，那么该输入点很可能存在 XSS 漏洞。 如果<>等标记符号都被过滤 / 转义了，我们也可以使用标签自身的属性 / 事件 (href，lowsrc，bgsound，backgroud，value，action，dynsrc 等) 来触发 XSS, 如<input name="xx" value=<?=$query?>>这里的 $query 属于动态内容，我们把他替换成恶意代码，最终的代码为<input name="xx" value=xss onmouseover=evil_script>。一般来说，针对输入框的黑盒测试可能存在反射型 XSS，也可能存在存储型 XSS，还有可能是 DOM 型，针对 Url 参数的黑盒测试绝大多数只存在反射型 XSS 或 DOM 型 XSS。    
> 工具检测：XSS 的自动检测软件有许多，如 Burp 的 Scan 模块，BruteXSS。  

### 预防措施
strip_tags() 函数,过滤掉输入、输出里面的恶意标签和使用 htmlentities() 函数把标签字符串转换成 html 实体。  

- 使用如下 PHP 函数对参数进行过滤
> 1, htmlspecialchars() 函数，用于转义处理在页面上显示的文本  
> 2, htmlentities() 函数，用于转义处理在页面上显示的文本  
> 3, strip_tags() 函数，过滤掉输入、输出里面的恶意标签  
> 4, header() 函数，使用 header("Content一type:application/json");  
> 5, urlencode() 函数，用于输出处理字符型参数带入页面链接中  
> 6, intval() 函数用于处理数值型参数输出页面中  

从如下三方面着手：  
1、输入  
严格控制用户可输入的范围，如手机号只能输入数字且长度不能大于 11 位等，如需输入某些敏感字符的情况下可对数据进行转义处理，对于用户数据的过滤尽可能地采用白名单而不是黑名单。  
2、输出
减少不必要的输出，在需要输出的地方使用 HTML 编码将敏感字符转义为实体符，javascript 进行 DOM 操作时注意不要将已转义的实体符再次解析成 DOM 对象。  
3、其他  
设置 HttpOnly，开启 WAF。
