

### 官方网站
[Python](https://www.python.org/)  

### IDE
[Pycharm](https://www.jetbrains.com/pycharm/)  

### 文档
[官方文档](https://docs.python.org/3/)  
[中文文档](http://www.pythondoc.com/)  
[cheatsheet](https://github.com/gto76/python-cheatsheet)  

### 代码规范
[官方风格](https://www.python.org/dev/peps/pep-0008/)  
[Google 风格](http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/) 

### 代码检测工具
[语法检查 pyflakes](https://pypi.python.org/pypi/pyflakes)  
[代码规范 pylint](https://www.pylint.org/)  
> 工具同样可以聚合在 pycharm  

### 框架
[Django](https://www.djangoproject.com/)  
[Django 最佳实践](https://github.com/yangyubo/zh-django-best-practices/blob/master/readme.rst)   

[Flask](http://flask.pocoo.org/)  
[Flask 之旅](http://spacewander.github.io/explore-flask-zh/) 

### 标准库
[2.x 标准库](https://docs.python.org/2/library/)  
[2.x how to](https://docs.python.org/2/howto/)  
[3.x 标准库](https://docs.python.org/3/library/)  
[3.x how to](https://docs.python.org/3/howto/)  

### 第三方库
[兼容性工具 Six](http://pythonhosted.org/six/)  
[HTTP 请求操作库 requests](https://github.com/kennethreitz/requests)  
[URL 处理器 purl](https://github.com/codeinthehole/purl)  
[清晰友好的 HTTP 库 urllib3](https://github.com/shazow/urllib3)  
[文件系统处理库 path.py](https://github.com/jaraco/path.py)  
[数据格式检查库 schema](https://github.com/halst/schema)  
[函数式增强库 fn.py](https://github.com/kachayev/fn.py)  
[时间日期库 when.py](https://github.com/dirn/When.py)  
[更好的时间日期库 arrow](https://github.com/crsmithdev/arrow)  
[命令行参数解析库 docopt](https://github.com/docopt/docopt)  
[代码风格处理库 autopep8](https://github.com/hhatto/autopep8)  

### 爬虫
[HTML\XML 搜索修改库 bs4](https://www.crummy.com/software/BeautifulSoup/bs4/doc/)  
[快速高级的屏幕爬取及网页采集框架 scrapy](https://github.com/scrapy/scrapy)  

### 数据分析
[科学计算基础包 Numpy](http://www.numpy.org/)  
[2D 绘图库 matplotlib](https://matplotlib.org/)  
[数据分析工具 Pandas](http://pandas.pydata.org/)  

### 深入理解  
[Python 格式化](https://pyformat.info/)  
[Python 挑战](http://www.pythonchallenge.com/)  
[Python 之旅](http://funhacks.net/explore-python/)  
[Python 进阶](http://interpy.eastlakeside.com/)  
[Python 最佳实践](http://pythonguidecn.readthedocs.io/zh/latest/)  
[Python 装饰器](https://zhuanlan.zhihu.com/p/65968462)  
[Python 设计模式](https://github.com/faif/python-patterns)  
[Python 代码分析](http://www.pythontutor.com/)  
[Python 数据分析](https://github.com/BrambleXu/pydata-notebook)  
[stackoverflow 中文问题集](https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/index.html)  
[Python 罕见问题](http://norvig.com/python-iaq.html)  

### 其他
[Python 之禅](https://foofish.net/)  
[Python 茶馆](https://pythoncaff.com/)  
[爱湃森 2017 榜单](https://annual2017.pycourses.com/)  
[爱湃森 2018 榜单](https://annual2018.pycourses.com/)  
[爱湃森 2019 榜单](https://annual2019.pycourses.com/)  

------
[廖雪峰 Python](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)  
[莫烦 Python](https://morvanzhou.github.io/)  

------
[更多 awesome](https://awesome-python.com/)  

### python 之禅
-- The Zen of Python, by Tim Peters  

Beautiful is better than ugly.  
Explicit is better than implicit.  
Simple is better than complex.  
Complex is better than complicated.  
Flat is better than nested.  
Sparse is better than dense.  
Readability counts.  
Special cases aren't special enough to break the rules.  
Although practicality beats purity.  
Errors should never pass silently.  
Unless explicitly silenced.  
In the face of ambiguity, refuse the temptation to guess.  
There should be one-- and preferably only one --obvious way to do it.  
Although that way may not be obvious at first unless you're Dutch.  
Now is better than never.  
Although never is often better than *right* now.  
If the implementation is hard to explain, it's a bad idea.  
If the implementation is easy to explain, it may be a good idea.  
Namespaces are one honking great idea -- let's do more of those!  

-- 中文版  
优美胜于丑陋（Python 以编写优美的代码为目标）  
明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）  
简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）  
复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）  
扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）  
间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）  
可读性很重要（优美的代码是可读的）  
即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）  
不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）  
当存在多种可能，不要尝试去猜测  
而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）  
虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）  
做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）  
如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）  
命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）  

### 这样的 Python 很优雅
1、简洁之美：一行代码  
```python
# 变量交换  
a, b = b, a

# 反转列表
[1,2,3][::-1] # [3,2,1]

# 合并两个字典
{**{'a':1,'b':2}, **{'c':3}} # {'a': 1, 'b': 2, 'c': 3}

# 列表去重
set([1,2,2,3,3,3]) # {1, 2, 3}

# 求多个列表中的最大值
max(max([ [1,2,3], [5,1], [4] ], key=lambda v: max(v))) # 5

# 生成逆序序列
list(range(10,-1,-1)) # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```

2、循环遍历区间元素  
```python
# xrange 返回的是生成器对象，生成器比列表更加节省内存
# 不过需要注意的是 xrange 是 python2 中的写法，python3 只有 range 方法，特点和 xrange 是一样的
for i in range(6):
    print(i)
```

3、带有索引位置的集合遍历  
遍历集合时如果需要使用到集合的索引位置时，直接对集合迭代是没有索引信息的。  
```python
colors = ['red', 'green', 'blue', 'yellow']
for i, color in enumerate(colors):
    print(i, '--->', color)
```

4、字符串连接  
字符串连接时，普通的方式可以用 + 操作  
```python
names = ['raymond', 'rachel', 'matthew']
# 使用 + 操作时，每执行一次 + 操作就会导致在内存中生成一个新的字符串对象
# 使用 join 方法整个过程只会产生一个字符串对象
print(', '.join(names))
```

5、打开 / 关闭文件  
执行文件操作时，最后一定不能忘记的操作是关闭文件，即使报错了也要 close。  

使用上下⽂管理器，它允许你在有需要的时候，精确地分配和释放资源。
```python
with open('test.txt') as f:
    data = f.read()

# 基于类的实现
# ⼀个上下⽂管理器的类，最起码要定义 __enter__ 和 __exit__ ⽅法
class File(object):
    def __init__(self, file_name, method):
        self.file_obj = open(file_name, method)

    def __enter__(self):
        return self.file_obj

    def __exit__(self, type, value, traceback):
        self.file_obj.close()
# 通过定义 __enter__ 和 __exit__ ⽅法，我们可以在 with 语句⾥使⽤它
with File('demo.txt', 'w') as opened_file:
    opened_file.write('Hola!')
#  __exit__ 函数接受三个参数，它们都是必须的
# with 语句先暂存了 File 类的 __exit__ ⽅法
# 然后它调⽤ File 类的 __enter__ ⽅法
# __enter__ ⽅法打开⽂件并返回给 with 语句
# 打开的⽂件句柄被传递给 opened_file 参数
# 我们使⽤ .write() 来写⽂件
# with 语句调⽤之前暂存的 __exit__ ⽅法
# __exit__ ⽅法关闭了⽂件
# 
# 如果发⽣异常，Python 会将异常的 type,value 和 traceback 传递给 __exit__ ⽅法，让__exit__⽅法来决定如何关闭⽂件以及是否需要其他步骤
# 如果__exit__返回的是True，那么这个异常就被优雅地处理了
# 如果__exit__返回的是True以外的任何东西，那么这个异常将被with语句抛出

# 还可以⽤装饰器(decorators)和⽣成器(generators)来实现上下⽂管理器
from contextlib import contextmanager

# contextmanager 会被调⽤并传⼊函数名（open_file）作为参数
@contextmanager
def open_file(name):
    f = open(name, 'w')
    yield f # 创建了⼀个⽣成器
    # contextmanager 函数返回⼀个以 GeneratorContextManager 对象封装过的⽣成器
    f.close()
# GeneratorContextManager 被赋值给 open_file 函数，我们实际上是在调⽤ GeneratorContextManager 对象
with open_file('some_file') as f:
    f.write('hola!')
```

6、列表推导式  
能够用一行代码简明扼要地解决问题时，绝不要用两行。  
列表推导式的格式：variable = [out_exp for out_exp in input_list if out_exp == 2] 
```python
[i for i in range(10)]
```

7、善用装饰器  
装饰器可以把与业务逻辑无关的代码抽离出来，让代码保持干净清爽，而且装饰器还能被多个地方重复利用。  
```python
import urllib.request as urllib

def cache(func):
    saved = {}

    def wrapper(url):
        if url in saved:
            return saved[url]
        else:
            page = func(url)
            saved[url] = page
            return page

    return wrapper

@cache
def web_lookup(url):
	# 一个爬虫网页的函数，如果该 URL 曾经被爬过就直接从缓存中获取，否则爬下来之后加入到缓存，防止后续重复爬取
    return urllib.urlopen(url).read()
```

8、合理使用列表  
列表对象（list）是一个查询效率高于更新操作的数据结构，比如删除一个元素和插入一个元素时执行效率就非常低，因为还要对剩下的元素进行移动。  
```python
from collections import deque

# deque 是一个双向队列的数据结构，删除元素和插入元素会很快
names = deque(['raymond', 'rachel', 'matthew', 'roger'])
names.popleft()
names.appendleft('mark')
```

9、序列解包  
```python
p = 'vttalk', 'female', 30, 'python@qq.com'
name, gender, age, email = p
```

10、遍历字典的 key 和 value  
```python
# 方法一
# 速度没那么快，因为每次迭代的时候还要重新进行 hash 查找 key 对应的 value
for k in d:
    print k, '--->', d[k]

# 方法二
# Python2 遇到字典非常大的时候，会导致内存的消耗增加一倍以上；iteritems 返回迭代器对象，可节省更多的内存
# Python3 的 items 等值于 iteritems
for k, v in d.items():
    print k, '--->', v
```

11、链式比较操作  
```python
age = 18
if 18 < age < 60:
    print("yong man")
```

12、if/else 三目运算  
```python
# 能够用 if/else 清晰表达逻辑时，就没必要再额外新增一种方式来实现
text = '男' if gender == 'male' else '女'
```

13、真值判断  
检查某个对象是否为真值时，还显示地与 True 和 False 做比较就显得多此一举，不专业。  
```python
if attr: # attr == True
    do_something()

if values: # len(values) != 0
    do_something()
```

14、for/else 语句  
for else 是 Python 中特有的语法格式，else 中的代码在 for 循环遍历完所有元素之后执行。  
```python
for i in mylist:
    if i == theflag:
        break
    process(i)
else:
    raise ValueError("List argument missing terminal flag.")
```

15、字符串格式化  
很难说用 format 比用 % s 的代码量少，但是 format 更易于理解。  
```python
s1 = "foofish.net"
s2 = "vttalk"
# s3 = "welcome to %s and following %s" % (s1, s2)
s3 = "welcome to {blog} and following {wechat}".format(blog="foofish.net", wechat="vttalk")
```

16、列表切片  
获取列表中的部分元素最先想到的就是用 for 循环根据条件提取元素，这也是其它语言中惯用的手段，而在 Python 中还有强大的切片功能。  
`注意：列表元素的下标不仅可以用正数表示，还是用负数表示，最后一个元素的位置是 -1，从右往左，依次递减。`
```python
items = range(10)
# 第1到第4个元素的范围区间
sub_items = items[1:4]
# 奇数
odd_items = items[1::2]
# 拷贝
copy_items = items[::] # 或者 items[:]
```

17、善用生成器  
生成器的好处就是无需一次性把所有元素加载到内存，只有迭代获取元素时才返回该元素，而列表是预先一次性把全部元素加载到了内存。此外用 yield 代码看起来更清晰。  

⽣成器也是⼀种迭代器，但是只能对其迭代⼀次。因为它们并没有把所有的值存在内存中，⽽是在运⾏时⽣成值。  
通过遍历来使⽤它们，要么⽤⼀个“for”循环，要么将它们传递给任意可以进⾏迭代的函数和结构。⼤多数时候⽣成器是以函数来实现的，它们并不返回⼀个值，⽽是 yield(暂且译作“⽣出”) ⼀个值。  
```python
# 用生成器生成费波那契数列
def fib(n):
    a, b = 0, 1
    while a < n:
        yield a
        a, b = b, a + b

for i in fib(9):
    print(i)
```

18、获取字典元素  
```python
d = {'name': 'foo'}
# 字典 key 不存在，设置默认值
d.get("name", "unknow")
```

19、预设字典默认值  
通过 key 分组的时候，不得不每次检查 key 是否已经存在于字典中。  
```python
data = [('foo', 10), ('bar', 20), ('foo', 39), ('bar', 49)]
groups = {}
for (key, value) in data:
    if key in groups:
        groups[key].append(value)
    else:
        groups[key] = [value]

#　第一种方式
groups = {}
for (key, value) in data:
    groups.setdefault(key, []).append(value) 

# 第二种方式
from collections import defaultdict
groups = defaultdict(list)
for (key, value) in data:
    groups[key].append(value)
```

20、字典推导式  
字典推导式是 python2.7 新增的特性，可读性增强了很多，类似的还是列表推导式和集合推导式。  
```python
numbers = [1, 2, 3]
my_dict = {number: number * 2 for number in numbers}
print(my_dict)  # {1: 2, 2: 4, 3: 6}

# 还可以指定过滤条件
my_dict = {number: number * 2 for number in numbers if number > 1}
print(my_dict)  # {2: 4, 3: 6}
```

21、函数缓存 (Function caching)  
函数缓存允许我们将⼀个函数对于给定参数的返回值缓存起来。  
当⼀个I/O密集的函数被频繁使⽤相同的参数调⽤的时候，函数缓存可以节约时间。在 Python 3.2 版本以前我们只有写⼀个⾃定义的实现；在 Python 3.2 以后版本，有个 lru_cache 的装饰器，允许我们将⼀个函数的返回值快速地缓存或取消缓存。  
```python
from functools import lru_cache

@lru_cache(maxsize=32)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

print([fib(n) for n in range(10)])
# 清空缓存
fib.cache_clear()
```

22、对象自省  
⾃省(introspection)，在计算机编程领域⾥，是指在运⾏时来判断⼀个对象的类型的能⼒。Python 中所有⼀切都是⼀个对象。  
```python
my_list = [1, 2, 3]
dir(my_list) # 列出了⼀个对象所拥有的属性和⽅法
# Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
# '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
# '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',
# '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',
# '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',
# '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',
# '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop',
# 'remove', 'reverse', 'sort']
dir() # 不传⼊参数，那么它会返回当前作⽤域的所有名字

# type 函数返回⼀个对象的类型
print(type('')) # <type 'str'>

# id() 函数返回任意不同种类对象的唯⼀ ID
name = "Yasoob"
print(id(name)) # 139972439030304

# inspect 模块获取活跃对象的信息
import inspect
print(inspect.getmembers(str)) # 比如查看⼀个对象的成员
# [('__add__', <slot wrapper '__add__' of ... ...
```

### Python 奇技淫巧
1、isinstance  
isinstance 函数可用于判断实例的类型，其实它的第二个参数可以是多个数据类型组成的元组。  
类似的函数还有字符串的 startswith 方法和 endswith 方法。  
```python
isinstance(x, (int, float))
# 等价于
isinstance(x, int) or isinstance(x, float)

s.startswith(('"""', "'''"))
# 等价于
s.startswith("'''") or s.startswith('"""')
```

2、用 http.server 共享文件  
通过浏览器方便局域网共享文件。  
```python
# python3
python3 -m http.server
# python2
python -m SimpleHTTPServer
```

3、zip 函数实现字典键值对互换  
```python
lang = {"python":".py", "java":".java"}
dict(zip(lang.values(), lang.keys())) # {'.java': 'java', '.py': 'python'}
```

4、查找列表中出现次数最多的数字  
```python
test = [1, 2, 3, 4, 2, 2, 3, 1, 4, 4, 4, 5]
print(max(set(test), key=test.count))
```

5、使用 \_\_slots\_\_ 节省内存  
特殊的 \_\_slots\_\_ 变量，用来限制该 class 实例能添加的属性。  
```python
class MyClass(object):
    def __init__(self, name, identifier):
        self.name = name
        self.identifier = identifier
        self.set_up()

print(sys.getsizeof(MyClass)) # 1016

class MyClass(object):
    __slots__ = ['name', 'identifier']

    def __init__(self, name, identifier):
        self.name = name
        self.identifier = identifier
        self.set_up()

print(sys.getsizeof(MyClass)) # 888
```
