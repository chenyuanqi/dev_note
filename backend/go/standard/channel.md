
### Go 通道
并发编程的最大调整源于数据的共享。如果你的协程间不存在数据共享，你完全没必要担心同步问题。但是并非所有系统都是如此简单。现实中，许多系统考虑了相反的目的：跨多个请求共享数据。内存缓存和数据库就是最好的例证。这种情况已经成为一个日趋增长的现实。
通道在共享不相关数据的情况下，让并发编程变得更健壮。通道是协程之间用于传递数据的共享管道。换而言之，一个协程可以通过一个通道向另外一个协程传递数据。因此，在任意时间点，只有一个协程可以访问数据。
一个通道，和其他任何变量一样，都有一个类型。这个类型是在通道中传递的数据的类型。

```golang
// 创建一个通道用于传递一个整数
c := make(chan int)
// 将通道传递给函数
func worker(c chan int) { ... }
```

通道只支持两个操作：接收和发送。  
往通道发送一个数据：CHANNEL <- DATA；从通道接收数据：VAR := <-CHANNEL。  
箭头预示着数据流向。当发送的时候，数据流向通道；接收的时候，数据流出通道。
`注意：接收和发送操作是阻塞的。也就是，当我们从一个通道接收的时候， goroutine 将会直到数据可用才会继续执行。类似地，当我们往通道发送数据的时候，goroutine 会等到数据接收到之后才会继续执行。`  

记住，唯一的共享状态时通道，我们可以安全地同时从它接收和发送数据。通道提供了所有我们需要的同步代码保证，在任何时间只有一个 goroutine 可以访问特定的数据。  
```golang
// 考虑这样一个系统，我们希望在各个 goroutine 中处理即将到来的数据
// 如果我们在接收数据的 goroutine 上进行数据密集型处理，那么我们可能导致客户端超时
type Worker struct {
  id int
}
func (w Worker) process(c chan int) {
  for {
    data := <-c
    fmt.Printf("worker %d got %d\n", w.id, data)
  }
}
// worker 是简单的，一直等到数据可用然后处理它
// 第一件事情是启动一些 workers
c := make(chan int)
for i := 0; i < 5; i++ {
  worker := &Worker{id: i}
  go worker.process(c)
}
// 给这些 worker 一些活干
// 我们不知道哪个 worker 将得到什么数据，但我们能确保的是 Go 保证了发送到通道的数据只会被一个接收器接收
for {
  c <- rand.Int()
  time.Sleep(time.Millisecond * 50)
}
```

**缓冲通道**  
在某些情况下，你可能需要担心数据被处理掉，这个时候就需要开始阻塞客户端。在某些情况下，你可能会降低这种担心。这有几种常用的策略实现它。第一个就是缓冲数据。如果没有 worker 可用，我们想去临时存储数据在某些队列中。通道内建这种缓冲容量，当我们使用 make 创建通道的时候，可以设置通道的长度：
```golang
c := make(chan int, 100)
```
你可以对此更改进行更改，但你会注意到处理仍然不稳定。缓冲通道不会增加容量，他们只提供待处理工作的队列，以及处理突然飙升的任务量的好方法。  
`通道长度一直增加直到满了，这个时候往我们的通道发送数据将再一次阻塞。`  

**Select**  
即使有缓冲，在某些时候我们需要开始删除消息。我们不能为了让 worker 轻松而耗尽所有内存。为了实现这个，我们使用 Go 的 select：
语法上，select 看起来有一点像 switch。使用它，我们提供当通道不能发送数据的时候处理代码。

```golang
c := make(chan int)
for {
  select {
    case c <- rand.Int():
      // 可选的代码在这里
    default:
      // 这里可以留空以静默删除数据
      fmt.Println("dropped")
  }
  time.Sleep(time.Millisecond * 50)
}
```
我们将每秒推送 20 条消息，但是我们的 worker 每秒仅仅能处理 10 条。也就是说，一半的消息，将被丢掉。  
这只是我们能使用 select 实现的一个开始。select 的主要目的是管理多个通道，select 将阻塞直到第一个通道可用。如果没有通道可用，如果提供了 default ，那么他就会被执行。如果多个通道都可用了，随机挑选一个。
很难用一个简单的例子来证明这个行为，因为它是一个相当高级的功能。  

**超时**  
另一个通用的选择是去超时。我们将阻塞一段时间，但不会永远。这在 Go 中也是很容易实现的。虽然，语法很难遵循，但是这样一个简洁有用的功能我不能将它排除在外。  
为了阻塞最长时间，我们可以用 time.After 函数。我们来一起看看它并试着超越魔法。  

```golang
// 发送器调整如下
for {
  select {
  case c <- rand.Int():
  case <-time.After(time.Millisecond * 100):
    fmt.Println("timed out")
  }
  time.Sleep(time.Millisecond * 50)
}
```
time.After 返回了一个通道，所以我们在 select 中使用它。这个通道可以在指定时间之后被写入。就这样，没有其他魔法了。  


